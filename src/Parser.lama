-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta (failure ("expression parsing not implemented\n"));

-- var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
--                                  x=lident  {Var (x)} |
--                                  x=inbr[s("("), exp, s(")")] {x}
--                                 ),
--       ops1 = memo $ eta syntax (s["*"] | s["/"] | s["%"]),
--       ops2 = memo $ eta syntax (s["+"] | s["-"] ),
--       ops3 = memo $ eta syntax (s["<"] | s["<="] | s[">"] | s[">="] | s["!="] | s["=="]),
--       ops4 = memo $ eta syntax (s["&&"]),
--       ops5 = memo $ eta syntax (s["!!"]),

--       exp = memo $ expr ({[Left, {[ops5, fun(l, op, r) {Binop(op, l, r)}]}],
--                           [Left, {[ops4, fun(l, op, r) {Binop(op, l, r)}]}],
--                           [Nona, {[ops3, fun(l, op, r) {Binop(op, l, r)}]}],
--                           [Left, {[ops2, fun(l, op, r) {Binop(op, l, r)}]}],
--                           [Left, {[ops1, fun(l, op, r) {Binop(op, l, r)}]}]
--                         },
--                          primary
--                         );

-- var stmt = memo $ eta syntax (kWrite x=inbr[s("("), exp, s(")")]    {Write (x)}  |
--                               kRead  x=inbr[s("("), lident, s(")")] {Read (x)}   |
--                               x=lident s[":="] y=exp                {Assn (x, y)}
--                              );

-- var stmts = memo $ eta syntax (x=stmt s[";"] y=stmts end {Seq (x, y)} |
--                                stmt);


-- Public top-level parser
public parse = stmt;

-- public parse = stmts;
