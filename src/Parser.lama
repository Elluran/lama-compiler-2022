-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)} |
                                 x=inbr[s("("), exp, s(")")] {x}
                                ),
      ops1 = memo $ eta syntax (s["*"] | s["/"] | s["%"]),
      ops2 = memo $ eta syntax (s["+"] | s["-"] ),
      ops3 = memo $ eta syntax (s["<"] | s["<="] | s[">"] | s[">="] | s["!="] | s["=="]),
      ops4 = memo $ eta syntax (s["&&"]),
      ops5 = memo $ eta syntax (s["!!"]),

      exp = memo $ expr ({[Left, {[ops5, fun(l, op, r) {Binop(op, l, r)}]}],
                          [Left, {[ops4, fun(l, op, r) {Binop(op, l, r)}]}],
                          [Nona, {[ops3, fun(l, op, r) {Binop(op, l, r)}]}],
                          [Left, {[ops2, fun(l, op, r) {Binop(op, l, r)}]}],
                          [Left, {[ops1, fun(l, op, r) {Binop(op, l, r)}]}]
                        },
                         primary
                        );

var stmtSeq = memo $ eta syntax (
  x=stmt s[";"] y=stmtSeq  {Seq (x, y)} |
  stmt
);

var ifExpr = memo $ eta syntax (
  kIf x=exp kThen y=stmtSeq kFi {If (x, y, Skip)}             |
  kIf x=exp kThen y=stmtSeq z=condElsePart kFi {If (x, y, z)}
), 
 condElsePart = memo $ eta syntax (
  kElif x=exp kThen y=stmtSeq {If (x, y, Skip)}             |
  kElif x=exp kThen y=stmtSeq z=condElsePart {If (x, y, z)} |
  kElse x=stmtSeq {x}
 );

var forLoop = memo $ eta syntax (
    kFor w=stmtSeq s[","] x=exp s[","] y=stmtSeq kDo z=stmtSeq kOd {Seq(w, While(x, Seq(z, y)))} 
);

var stmt = memo $ eta syntax (kWrite x=inbr[s("("), exp, s(")")]    {Write (x)}       |
                              kRead  x=inbr[s("("), lident, s(")")] {Read (x)}        |
                              x=lident s[":="] y=exp                {Assn (x, y)}     |
                              kWhile x=exp kDo y=stmtSeq kOd        {While (x, y)}    |
                              kDo x=stmtSeq kWhile y=exp kOd        {DoWhile (x, y)}  |
                              x=stmt s[";"] y=stmt end              {Seq (x, y)}      |
                              kSkip                                 {Skip}            |
                              ifExpr                                                  |
                              forLoop
                             );

-- Public top-level parser
public parse = stmt;
